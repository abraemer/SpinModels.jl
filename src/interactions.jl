###########################################
############### Interaction ###############
###########################################

abstract type Interaction end

### Private Interface
function _compute_interaction end

### Public Interface
"""
    interaction_matrix(interaction, geometry[, positions]; rng)
    (::Interaction)(geometry[, positions]; rng)

Compute the corresponding interaction matrix from `interaction` and `geometry`.
Positions are generated by the `geometry` via [`positions`](@ref) or provided directly.
Disordered geometries allow for setting an `RNG`.
"""
function interaction_matrix end

### default implementation
(interaction::Interaction)(args...;kwargs...) = interaction_matrix(interaction, args...; kwargs...)

interaction_matrix(interaction, geom; kwargs...) = interaction_matrix(interaction, geom, positions(geom; kwargs...))

function interaction_matrix(interaction, geom, positions)
    N = nspins(geom)
    res = zeros(N, N)
    dists = distance_matrix(geom, positions)
    for i in 1:N
        for j in i+1:N
            dists[i,j] == Inf && continue
            dist = _compute_interaction(interaction, geom, positions[:,i], positions[:,j])
            res[i,j] = dist
            res[j,i] = dist
        end
    end
    return res
end


### Implementation: ConstantInteraction
"""
    ConstantInteraction(value)

Represents a simple constant valued interaction.

There are quality of life overloads, that removes the need to use
`ConstantInteraction(1)(geometry)` such that you can simply use the geometry like an
interaction matrix in most scenarios. Please complain if this produces unintuitive behavior.
"""
struct ConstantInteraction{T} <: Interaction
    val::T
end
_compute_interaction(c::ConstantInteraction, _, _, _) = c.val

# quality of life overloads
Base.:*(geom::Geometry, h::Hamiltonian) = ConstantInteraction(1)(geom)*h
Base.:*(h::Hamiltonian, geom::Geometry) = h*ConstantInteraction(1)(geom)
Base.:*(geom::Geometry, v::Number) = ConstantInteraction(1)(geom)*v
Base.:*(v::Number, geom::Geometry) = v*ConstantInteraction(1)(geom)

### Implementation: PowerLaw
"""
    PowerLaw(α)

Represents couplings decaying as ``|x_i-x_j|^{-\\alpha}``
"""
struct PowerLaw <: Interaction
    α::Float64
end
_compute_interaction(p::PowerLaw, geom, p1, p2) = _distance(geom, p1,p2)^(-p.α)


### Implementation: NNInteraction
"""
    NNInteraction(interaction, k)

See [`NN(::SpinModels.Interaction)`](@ref) and [`nearest_neighbor_from_interactions!`](@ref).
"""
struct NNInteraction{I} <: Interaction
    interaction::I
    k::Int
    NNInteraction(interaction; k=1) = new{typeof(interaction)}(interaction, k)
end

## Helpers
"""
    nearest_neighbor_from_interactions(interaction_matrix, k=1)

Non-destructive form of [`nearest_neighbor_from_interactions!`](@ref).
See also: [`nearest_neighbor_from_distances!`](@ref)
"""
nearest_neighbor_from_interactions(interaction_mat, k=1) = nearest_neighbor_from_interactions!(copy(interaction_mat), k)

"""
    nearest_neighbor_from_interactions!(interaction_matrix, k=1)

Set all but the `k` strongest couplings from each column to `0`. `k` only counts *different* values!
Thus `k=1` keeps only the strongest couplings per spin but allows to have the same value multiple times.

Note: The resulting matrix won't necessarily be symmetric if nearest neighbors are ill-defined.
See also: [`nearest_neighbor_from_distances!`](@ref)
"""
function nearest_neighbor_from_interactions!(interaction_mat, k=1)
    cutoffs = [sort!(unique(col); rev=true)[k] for col in eachcol(interaction_mat)] # k largest interactions
    interaction_mat[interaction_mat .< cutoffs'] .= 0 # not nearest nearest_neighbor = infinitely far away
    # could also consider converting to sparse but probably not worth it most of the times?
    # for sparse matrices simply remove the entry and not set it to Inf?
    return interaction_mat
end

## overwrite default
function interaction_matrix(nn::NNInteraction, geom, positions)
    J = interaction_matrix(nn.interaction, geom, positions)
    return nearest_neighbor_from_interactions!(J, nn.k)
end
